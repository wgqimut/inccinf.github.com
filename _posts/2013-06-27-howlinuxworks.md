---
layout: post
title: "Linux操作系统是如何工作的"
description: ""
category: "Linux Class Experiments"
tags: [实验, linux]
---
{% include JB/setup %}

---

本文作为“linux操作系统分析 of USTC”实验五的报告    
姓名：王磊  
学号：SA12226224  

---

###一、操作系统工作基础
现代操作系统由存储程序计算机模型、调用堆栈和中断机制等基础构成。我们的课程也始终围绕这些概念展开。  

1.目前绝大部分计算机都是冯诺依曼体系结构的，即***存储结构计算机***，其最主要的特点就是在任何程序运行之前，都需要将其代码和数据放入主存储器中，这就决定了计算机的任何操作都需要围绕内存这一主题来进行。  

2.内存中的一种最重要的数据结构就是***堆栈***，这也是由图灵机模型自然发展而来的。操作系统使用堆栈来辅助完成函数调用等重要的功能。函数调用时，调用者首先会将参数以及返回地址（下一条指令的EIP）压入栈中，并将当前EIP修改为被调用函数的起始地址；被调用者开始执行后先将原栈基址EBP保存在栈中，并修改EBP和ESP的值，初始化一个新栈。返回时，被调用者恢复EBP和ESP，并且将EIP修改为栈中存储的返回地址。可以在[这里](http://en.wikipedia.org/wiki/Call_stack)看到更详细的调用堆栈结构及存储过程。  

3.传统的单任务计算机只有一个控制流，为了在单CPU机器上实现多任务，同时也为了减少低速外设对CPU的阻塞，操作系统引入了***中断***的概念。现代操作系统中包括进程切换、系统调用、设备驱动等重要组成部分都依赖于中断机制。中断有多种类型，如可屏蔽中断、非屏蔽中断、处理器终端和软中断等，当中断发生时，CPU停止当前执行流，转而运行中断处理程序。进程切换就是依赖于这种特性进行的，进程调度器使用时间片轮转算法，当进过一个时间片后，由时钟中断触发timer_interrupt()函数，产生新一轮的进程调度。  

  
###二、内核如何工作
上一个部分已经简述了内核工作所依赖的一些关键特性，Linux内核通过使用这些关键特性来完成工作。  
内核启动时只有一个控制流，它完成一些初始化工作，初始化关键的数据结构以及加载模块和驱动，启用中断后，内核便拥有了多控制流的执行能力。之后系统可能会开始一个用户态的初始程序，比如shell，使用者在shell中输入一些命令后，系统运行对应的程序，首先fork一个shell进程，然后使用exec加载新程序代码，将新进程加入到进程调度队列中，进程调度器在相应的时钟中断发生后挑选一个进程开始执行，由于进程调度的时间片极短，所以即使在单CPU的计算机上，多个进程也可以“并发”执行。  
用户程序有可能需要使用一些特权级较高的功能，此时会使用到Linux的系统调用，系统调用也是中断的一种（int 0x80），系统调用中断服务程序通过系统调用号选择相应的系统调用程序在内核态中代用户态进程完成相应功能（处于相同的进程上下文），这就是所谓的“陷入内核”。  
Linux内核还有很多特性和功能，但都脱离不了这些工作基础和关键过程。不过，Linux内核始于1991年，那是一个单核CPU的时代，Linux内核的很多特性都是基于那样的时代和技术背景下开发的，虽然得益于开源社区的通力合作，Linux内核在不断发展着，但是为了各种兼容性问题或者历史问题，Linux内核也不能过于“激进”，在多核大行其道，“云”的概念深入人心的今天，也许Linux内核的很多概念都有些陈旧而低效，但又不得已为之，也许不远的未来，一个更加符合时代特性，更加高效的新内核会像当初Linux一样脱颖而出呢。   

---
【1】关于中断的更多详情，可以查看<http://zh.wikipedia.org/zh-cn/中斷>  

【2】关于进程调度及其实现的详细理解，查看  
<http://blog.csdn.net/sailor_8318/article/details/2396756>